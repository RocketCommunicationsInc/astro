import { Meta } from '@storybook/blocks'

<Meta title="Frameworks/Angular" />

# Angular (v10+)

For your convenience, we offer a wrapper library for our Angular components. Out of the box, Angular already has [very good support for Custom Elements](https://custom-elements-everywhere.com/libraries/angular/results/results.html).
Our wrapper library builds on top of that and adds:

1. Support for ngModel
2. Custom accessors for our form components so that you can use Angular's Reactive Forms and built validation.
3. Better typescript intellisense and autocompletion.

## Versions

The `7.0` version of `@astrouxds/angular` is compatible with Angular 12 and 13. Starting with version `8.0`, we support Angular 20+ with standalone components. If you're using an older Angular version, you'll want to use `@astrouxds/angular@6.9`.

## Installation

### Requirements

- Node.js 18 or higher
- Angular 10+ (see Versions section above)

### Via NPM

`npm i @astrouxds/angular`

## Integration

### Angular 20+ (Standalone Components)

**BREAKING CHANGE:** Starting with Angular 20, `AstroComponentsModule` no longer exports individual components due to standalone component restrictions.

Import components individually:

```js
// app.component.ts or your component file
import { RuxButton, RuxIcon, RuxInput } from '@astrouxds/angular'

@Component({
    selector: 'app-root',
    standalone: true,
    imports: [RuxButton, RuxIcon, RuxInput], // Import only the components you need
    template: `
        <rux-button>Click me</rux-button>
        <rux-icon icon="apps"></rux-icon>
    `
})
export class AppComponent {}
```

### Angular 12-13 (Module-based)

Import `AstroComponentsModule`:

```js
// app.module.ts
import { BrowserModule } from '@angular/platform-browser'
import { NgModule } from '@angular/core'
import { AstroComponentsModule } from '@astrouxds/angular'

import { AppComponent } from './app.component'

@NgModule({
    declarations: [AppComponent],
    imports: [BrowserModule, AstroComponentsModule],
    bootstrap: [AppComponent]
})
export class AppModule {}
```

> NOTE: For Angular 20+, components are imported individually as standalone components. For Angular 12-13, when using the `AstroComponentsModule`, components are lazy loaded only when they appear on the page.

Import Astro's CSS custom properties

```css
// styles.scss
@import '@astrouxds/astro-web-components/dist/astro-web-components/astro-web-components.css';
```

Import [Roboto](https://fonts.google.com/specimen/Roboto) in your index.html. We recommend using Google's CDN for ease of use but you can also install it locally.

```html
<link rel="preconnect" href="https://fonts.gstatic.com" />
<link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
    rel="stylesheet"
/>
```

Astro Components are now available anywhere in your app.

## With Typescript

All of our component types can be imported from `@astrouxds/astro-web-components`.

## Using our CSS Variables (Design Tokens).

While our components may solve 60% of your UI needs, you will inevitably find yourself needing to
create your own custom UI in the style of Astro.

Our Astro Web Components are powered by our Design Tokens under the hood. These are imported
and made available to you when you import `astro-web-components.css` in the form of CSS Custom Properties.
Our Design Tokens include everything from our color palette to our spacing system.

We also provide our tokens in other formats (SASS, json) for your convenience. For more information,
check out our [Design Tokens](https://www.astrouxds.com/design-tokens/installation/) page for a list
of our available tokens and their intended usage.

## Setting Props

### Basic Data

For basic primitive types like `string`, `boolean`, `number`, set the attribute on the element:

```html
<rux-button size="large"></rux-button>
```

### Dynamic Data

Alternatively props can be set dynamically via property binding. This option is useful in `*ngFor` loops when
data is not instantly available.

```js
const buttons = [
    { size: 'small', type: 'button', text: 'First' },
    { size: 'medium', type: 'button', text: 'Second' },
    { size: 'large', type: 'submit', text: 'Submit' },
]
```

```html
<div *ngFor="let button of buttons">
    <rux-button [size]="button.size" [type]="button.type"
        >{{ button.text }}</rux-button
    >
</div>
```

## Using Slots

Slots give you full control over the contents of a component. Some components may have multiple slots.

> Web Component Concept:
> Slotted content lives outside of the shadow DOM and as a result, you are free to style them however you want.

```html
<rux-global-status-bar>
    <rux-icon slot="left-side" icon="apps"></rux-icon>
    <div slot="app-meta">
        <h1>Hello World</h1>
    </div>
</rux-global-status-bar>
```

## Listening To Events

```html
<rux-input name="myInput" (ruxinput)="onInputChange($event)"></rux-input>
```

In TypeScript, accessing the events target value requires some type assertion.

```js

onInputChange(e: CustomEvent<HTMLRuxInputFieldElement>){
  const target = e.target as HTMLInputElement;
  console.log(`Here is e.target.value: ${target.value}`)
}
```

## Methods

Some components offer public methods that can be executed. These methods are async and can be executed by setting a ViewChild decorator on the element.
The Angular docs for setting and using `ViewChild` decorator can be found [here](https://angular.io/api/core/ViewChild).

```html
<rux-pop-up-menu #myPopUpMenu id="pop-up-menu">
    <rux-menu-item value="1">Item 1</rux-menu-item>
    <rux-menu-item-divider></rux-menu-item-divider>
    <rux-menu-item value="2">Item 2</rux-menu-item>
</rux-pop-up-menu>
```

```js
import { Component, ViewChild } from '@angular/core'

@Component({
    selector: 'app-example',
    templateUrl: './example.component.html',
})
export class ExampleComponent {
    @ViewChild('myPopUpMenu')
    myTestPopUpMenu: ElementRef<HTMLRuxPopUpMenuElement>
    async onAction() {
        await this.myTestPopUpMenu.nativeElement.isOpen()
    }
}
```

## Usage Without Wrapper

Our `@astrouxds/angular` wrapper library provides a number of quality of life features that enhance our core web component library. However, you may find it more convenient to use the core library directly if:

1. You aren't using Angular's Reactive Forms.
2. You don't need Angular's template checking.
3. You are using an older version of Angular (\< 10).

### Installation

1. `npm i @astrouxds/astro-web-components`

2. Register the custom elements

```
// main.ts
import { defineCustomElements } from '@astrouxds/astro-web-components/loader';
defineCustomElements();
```

3. Import `CUSTOM_ELEMENTS_SCHEMA`

```js
// app.module.ts
import { BrowserModule } from '@angular/platform-browser'
import { CUSTOM_ELEMENTS_SCHEMA, NgModule } from '@angular/core'

import { AppComponent } from './app.component'

@NgModule({
    declarations: [AppComponent],
    imports: [BrowserModule],
    bootstrap: [AppComponent],
    schemas: [CUSTOM_ELEMENTS_SCHEMA],
})
export class AppModule {}
```

4. Install Astro's CSS custom properties

```css
// styles.scss
@import '@astrouxds/astro-web-components/dist/astro-web-components/astro-web-components.css';
```

5. Import [Roboto](https://fonts.google.com/specimen/Roboto) in your index.html. We recommend using Google's CDN for ease of use but you can also install it locally.

```html
<link rel="preconnect" href="https://fonts.gstatic.com" />
<link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
    rel="stylesheet"
/>
```
