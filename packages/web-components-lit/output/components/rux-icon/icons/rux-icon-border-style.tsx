To convert your Stencil.js component to LitElement, we'll replace Stencil-specific decorators and syntax with their Lit equivalents.

Here's a breakdown of the changes:

1.  **Imports**: Replace Stencil's `Component`, `Prop`, and `h` with Lit's `LitElement`, `html`, `css`, `property`, and `unsafeSVG`.
2.  **Class Definition**: Extend `LitElement`.
3.  **`@Component`**: This decorator is replaced by `static properties` for props and `static styles` for CSS (though in your case, dynamic inline styles are used, so `static styles` isn't strictly necessary here unless you add other fixed styles). Lit components default to using Shadow DOM, unlike your Stencil component's `shadow: false`. If you *must* render to the light DOM, you'd override `createRenderRoot`. For an icon, Shadow DOM is generally beneficial for encapsulation.
4.  **`@Prop`**: Replaced by the `@property` decorator from `lit/decorators.js`.
5.  **`render()` Method**:
    *   Stencil's `h` (JSX factory) is replaced by Lit's `html` tagged template literal.
    *   `innerHTML` is replaced by the `unsafeSVG` directive from `lit/directives/unsafe-svg.js` to safely inject the SVG string.
    *   Inline styles are applied directly using string interpolation within the `style` attribute.
6.  **Custom Element Registration**: Add `customElements.define('your-tag-name', YourComponentClass)` at the end of the file.

Here's the converted LitElement code:

```typescript
import { LitElement, html } from 'lit';
import { property } from 'lit/decorators.js';
import { unsafeSVG } from 'lit/directives/unsafe-svg.js';
import svgIcon from '../../../icons/border-style.svg'; // Assuming this imports the SVG as a string

/**
 * WARNING: This is an autogenerated component.
 * Do not make any changes to this file or they will be overwritten on build.
 * The template for this file is located in the generate-icons.js util file.
 * /

/** @internal **/
// LitElement components use Shadow DOM by default for encapsulation.
// The original Stencil component had `shadow: false`. If rendering directly
// into the light DOM is a strict requirement for your use case (e.g., for
// global CSS to target the SVG paths without `:host` or `::part`),
// you would override `createRenderRoot` like this:
//
// protected createRenderRoot(): Element | ShadowRoot {
//   return this; // Renders directly into the element's light DOM
// }
//
// However, for injecting SVG via `unsafeSVG`, rendering within the Shadow DOM
// works perfectly and provides better component encapsulation.
export class RuxIconBorderStyle extends LitElement {
    /**
     * The size of the icon. Can be 'extra-small', 'small', 'normal', 'large', 'auto' or any custom value ('30px', '1rem', '3.321em')
     */
    @property({ type: String })
    size:
        | 'extra-small'
        | 'small'
        | 'normal'
        | 'large'
        | 'auto'
        | string = 'auto';

    // No `static styles` are needed here, as styling is handled dynamically via inline attributes.

    get iconSize(): string { // Ensure return type is string
        const sizes: { [key: string]: string } = {
            'extra-small': '1rem',
            small: '2rem',
            normal: '3rem',
            large: '4rem',
        };

        // If a predefined size matches, return it. Otherwise, return the custom size.
        if (this.size && sizes[this.size]) {
            return sizes[this.size];
        } else {
            return this.size;
        }
    }

    render() {
        // Construct the inline style string
        const dynamicStyle = `height: ${this.iconSize}; width: ${this.iconSize}; display: inline-block;`;
        // Adding display: inline-block to the div containing the SVG is a common practice
        // to ensure it respects width/height properly if the SVG itself doesn't have it set.

        return html`
            <div style="${dynamicStyle}">
                ${unsafeSVG(svgIcon)}
            </div>
        `;
    }
}

// Register the custom element with the browser
customElements.define('rux-icon-border-style', RuxIconBorderStyle);
```