To convert the Stencil.js component to LitElement, we need to:

1.  Replace Stencil-specific imports (`Component`, `Prop`, `h`) with Lit's (`LitElement`, `html`, `property`).
2.  Change the component decorator (`@Component`) to extend `LitElement`.
3.  Convert Stencil's `@Prop` decorator to Lit's `@property` decorator within the class, along with the `static properties` declaration (though `@property` decorator handles this automatically).
4.  Translate the `render()` method from JSX (`h`) to Lit's tagged template literals (`html`).
5.  Handle the `shadow: false` option from Stencil. In Lit, this is achieved by overriding the `createRenderRoot()` method to return `this`, making the component render directly into its light DOM.
6.  Ensure dynamic styles are correctly applied using Lit's `styleMap` directive.
7.  Define the custom element using `customElements.define()`.

Here's the converted LitElement code:

```typescript
import { LitElement, html } from 'lit';
import { property } from 'lit/decorators.js'; // For @property decorator
import { styleMap } from 'lit/directives/style-map.js'; // For dynamic inline styles
import svgIcon from '../../../icons/add-photo-alternate.svg';

/**
 * WARNING: This is an autogenerated component.
 * Do not make any changes to this file or they will be overwritten on build.
 * The template for this file is located in the generate-icons.js util file.
 * /

/** @internal **/
export class RuxIconAddPhotoAlternate extends LitElement {
    // The original Stencil component had `shadow: false`, which means it rendered
    // its content directly into the Light DOM of the host element, rather than
    // into a Shadow DOM. To replicate this behavior in LitElement, we override
    // `createRenderRoot` to return the element itself.
    protected createRenderRoot(): Element | DocumentFragment {
        return this;
    }

    /**
     * The size of the icon. Can be 'extra-small', 'small', 'normal', 'large', 'auto' or any custom value ('30px', '1rem', '3.321em')
     */
    @property({ type: String })
    size:
        | 'extra-small'
        | 'small'
        | 'normal'
        | 'large'
        | 'auto'
        | string = 'auto';

    get iconSize(): string {
        const sizes: { [key: string]: string } = {
            'extra-small': '1rem',
            small: '2rem',
            normal: '3rem',
            large: '4rem',
        };

        if (sizes[this.size]) {
            return sizes[this.size];
        } else {
            return this.size;
        }
    }

    render() {
        const style = {
            height: this.iconSize,
            width: this.iconSize,
        };

        // Use Lit's `html` tagged template literal for rendering.
        // `styleMap` is used for dynamic inline styles.
        // `.innerHTML` property binding is used to inject the SVG string.
        return html`<div style=${styleMap(style)} .innerHTML=${svgIcon}></div>`;
    }
}

// Define the custom element. This is necessary for the browser to recognize your component.
declare global {
    interface HTMLElementTagNameMap {
        'rux-icon-add-photo-alternate': RuxIconAddPhotoAlternate;
    }
}
customElements.define('rux-icon-add-photo-alternate', RuxIconAddPhotoAlternate);
```