To convert the Stencil.js component to LitElement, we'll make the following changes:

1.  **Base Class**: Extend `LitElement` instead of just being a class with `@Component`.
2.  **Properties**: Use the `@property` decorator from `lit/decorators.js` instead of `@Prop()`.
3.  **Rendering**: Replace Stencil's `h` function with Lit's `html` tagged template literal.
4.  **Styling**: Use Lit's `styleMap` directive for dynamic inline styles.
5.  **SVG Injection**: Use Lit's `unsafeHTML` directive to inject the raw SVG string, as `innerHTML` content needs explicit handling for safety and correct parsing.
6.  **Component Registration**: Manually call `customElements.define` to register the web component.
7.  **Shadow DOM**: LitElement defaults to using a Shadow DOM. Stencil's `shadow: false` renders to the light DOM. For an icon, using Shadow DOM in Lit is generally preferred for encapsulation, and the inline styles will work correctly within it.

Here's the converted LitElement code:

```typescript
import { LitElement, html, css } from 'lit';
import { property } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { unsafeHTML } from 'lit/directives/unsafe-html.js'; // Crucial for injecting raw SVG string

// Assuming this import resolves to a string containing the SVG markup
import svgIcon from '../../../icons/border-horizontal.svg';

/**
 * WARNING: This is an autogenerated component.
 * Do not make any changes to this file or they will be overwritten on build.
 * The template for this file is located in the generate-icons.js util file.
 */

/** @internal **/
export class RuxIconBorderHorizontal extends LitElement {
    // LitElement components typically render into their Shadow DOM by default,
    // which provides encapsulation. This differs from Stencil's `shadow: false`
    // but is generally a preferred pattern for web components like icons.

    /**
     * The size of the icon. Can be 'extra-small', 'small', 'normal', 'large', 'auto' or any custom value ('30px', '1rem', '3.321em')
     */
    @property({ type: String })
    size:
        | 'extra-small'
        | 'small'
        | 'normal'
        | 'large'
        | 'auto'
        | string = 'auto';

    // If there were any static CSS styles needed for the component itself
    // (e.g., display: block, padding, etc.), they would go here.
    // For this specific component, inline styles are used directly on the div.
    // static styles = css`
    //   :host {
    //     display: inline-block;
    //   }
    // `;

    get iconSize(): string {
        const sizes: { [key: string]: string } = {
            'extra-small': '1rem',
            small: '2rem',
            normal: '3rem',
            large: '4rem',
        };

        if (sizes[this.size]) {
            return sizes[this.size];
        } else {
            return this.size;
        }
    }

    render() {
        const style = {
            height: this.iconSize,
            width: this.iconSize,
        };

        // Use `styleMap` for the inline style object
        // Use `unsafeHTML` to render the `svgIcon` string as actual HTML/SVG elements
        return html`
            <div style=${styleMap(style)}>
                ${unsafeHTML(svgIcon)}
            </div>
        `;
    }
}

// Define the custom element using the component's tag name
customElements.define('rux-icon-border-horizontal', RuxIconBorderHorizontal);
```