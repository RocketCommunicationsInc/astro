To convert your Stencil.js component to LitElement, we need to make the following changes:

1.  **Imports**: Replace Stencil's core imports with Lit's `LitElement`, `html`, `css`, and `property` decorator.
2.  **Class Definition**: Extend `LitElement` instead of just being a class with `@Component`.
3.  **Properties**: Convert Stencil's `@Prop()` decorator to Lit's `@property()` decorator or `static properties` block.
4.  **Shadow DOM**: The original Stencil component explicitly sets `shadow: false`. LitElement defaults to using Shadow DOM. To match the Stencil behavior, we must override `createRenderRoot` to return `this`, which makes the component render its content directly into the light DOM.
5.  **Render Method**: Convert Stencil's JSX-like `h()` usage to Lit's `html` tagged template literal. Inline styles are handled similarly, and `innerHTML` is set using a property binding (`.innerHTML`).
6.  **Custom Element Definition**: Replace the `@Component({ tag: '...' })` decorator with `customElements.define('your-tag-name', YourClass)`.

Here's the converted LitElement component:

```typescript
import { LitElement, html, css } from 'lit';
import { property } from 'lit/decorators.js';
import svgIcon from '../../../icons/alarm-add.svg';

/**
 * WARNING: This is an autogenerated component.
 * Do not make any changes to this file or they will be overwritten on build.
 * The template for this file is located in the generate-icons.js util file.
 */

/** @internal **/
export class RuxIconAlarmAdd extends LitElement {
    // Stencil's `shadow: false` means the component renders to the light DOM.
    // LitElement defaults to Shadow DOM. To match the original behavior,
    // we override `createRenderRoot` to return `this`.
    createRenderRoot() {
        return this;
    }

    // No specific static styles defined in the original Stencil component,
    // only inline styles are used in render().
    // An empty `static styles` block is still good practice for LitElement.
    static styles = css`
        /* No component-specific CSS required outside of inline styles for the SVG container. */
    `;

    /**
     * The size of the icon. Can be 'extra-small', 'small', 'normal', 'large', 'auto' or any custom value ('30px', '1rem', '3.321em')
     */
    @property({ type: String })
    size: 'extra-small' | 'small' | 'normal' | 'large' | 'auto' | string = 'auto';

    get iconSize() {
        const sizes: { [key: string]: string } = {
            'extra-small': '1rem',
            small: '2rem',
            normal: '3rem',
            large: '4rem',
        };

        if (sizes[this.size]) {
            return sizes[this.size];
        } else {
            return this.size;
        }
    }

    render() {
        // Using string interpolation for inline styles directly in the template.
        // Use `.innerHTML` property binding to insert the SVG string directly.
        return html`
            <div style="height: ${this.iconSize}; width: ${this.iconSize};" .innerHTML="${svgIcon}"></div>
        `;
    }
}

// Define the custom element, similar to Stencil's @Component({ tag: '...' })
customElements.define('rux-icon-alarm-add', RuxIconAlarmAdd);
```