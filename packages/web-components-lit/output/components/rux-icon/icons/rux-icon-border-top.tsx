Okay, let's convert this Stencil.js component to LitElement.

Here's the breakdown of changes:

1.  **Imports:**
    *   `@stencil/core` is replaced with `lit` and `lit/decorators.js` for `LitElement`, `html`, `css`, `customElement`, and `property`.
    *   `lit/directives/unsafe-html.js` is needed for `innerHTML`.
    *   `lit/directives/style-map.js` is used for dynamic inline styles in a more idiomatic Lit way.
2.  **Component Decorator:**
    *   `@Component({ tag: ..., shadow: false })` becomes `@customElement('rux-icon-border-top')`. LitElement renders to Shadow DOM by default, which is generally preferred. If you *strictly* needed the `shadow: false` behavior (meaning rendering into the light DOM of the parent), you would override `createRenderRoot()` but it's rarely recommended. For SVG icons, Shadow DOM is usually fine.
3.  **Prop Decorator:**
    *   `@Prop()` becomes `@property()`. We also specify the `type` for clarity and better reflection behavior.
4.  **`render()` Method:**
    *   Instead of `h` (or JSX being transpiled by Stencil), we use Lit's `html` tagged template literal.
    *   `innerHTML={svgIcon}` is replaced with `unsafeHTML(svgIcon)` from `lit/directives/unsafe-html`.
    *   Inline styles are best managed with `styleMap` from `lit/directives/style-map.js`.
5.  **`static styles`:** LitElement components typically define their styles in a `static styles` property using the `css` tagged template literal. While your original component used inline styles, it's good practice to include a `static styles` block for component-level CSS, even if minimal. I've added basic styling for the host and the internal div to ensure proper icon rendering (e.g., `display: inline-block` and `line-height: 1`).

Here's the converted code:

```typescript
import { LitElement, html, css } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { unsafeHTML } from 'lit/directives/unsafe-html.js';
import { styleMap } from 'lit/directives/style-map.js';

// Assuming this path is correct relative to the component
import svgIcon from '../../../icons/border-top.svg';

/**
 * WARNING: This is an autogenerated component.
 * Do not make any changes to this file or they will be overwritten on build.
 * The template for this file is located in the generate-icons.js util file.
 */

@customElement('rux-icon-border-top')
export class RuxIconBorderTop extends LitElement {
    /**
     * The size of the icon. Can be 'extra-small', 'small', 'normal', 'large', 'auto' or any custom value ('30px', '1rem', '3.321em')
     */
    @property({ type: String })
    size:
        | 'extra-small'
        | 'small'
        | 'normal'
        | 'large'
        | 'auto'
        | string = 'auto';

    // LitElement's static styles property
    static styles = css`
        :host {
            display: inline-block; /* Ensures the custom element behaves like an inline element */
            line-height: 1; /* Prevents extra space below the SVG */
        }
        div {
            /* Ensures the div containing the SVG has appropriate display */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* You might add more specific SVG styling here if needed,
           e.g., svg { fill: currentColor; } if you want it to inherit text color */
    `;

    get iconSize() {
        const sizes: { [key: string]: string } = {
            'extra-small': '1rem',
            small: '2rem',
            normal: '3rem',
            large: '4rem',
        };

        if (sizes[this.size]) {
            return sizes[this.size];
        } else {
            return this.size;
        }
    }

    render() {
        const iconStyle = {
            height: this.iconSize,
            width: this.iconSize,
        };

        return html`<div style=${styleMap(iconStyle)}>${unsafeHTML(svgIcon)}</div>`;
    }
}
```