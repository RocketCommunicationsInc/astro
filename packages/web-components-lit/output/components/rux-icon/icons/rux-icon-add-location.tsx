To convert your Stencil.js component to LitElement, we'll need to make the following changes:

1.  **Imports**: Replace Stencil-specific imports (`Component`, `Prop`, `h`) with Lit's (`LitElement`, `html`, `property`, `styleMap`, `unsafeHTML`).
2.  **Base Class**: Extend `LitElement` instead of being a plain class decorated by `@Component`.
3.  **Tag Name**: Use `static is` to define the custom element's tag name.
4.  **Shadow DOM**: Since your Stencil component uses `shadow: false`, meaning it renders into the light DOM, we'll override Lit's `createRenderRoot` method to achieve the same behavior. *Note: For most LitElement components, using Shadow DOM is recommended for encapsulation. This override is for a direct functional conversion.*
5.  **Properties**: Replace Stencil's `@Prop()` decorator with Lit's `@property()` decorator.
6.  **Rendering**: Convert Stencil's JSX-like `render()` method to Lit's `html` template literal syntax, using `styleMap` for dynamic styles and `unsafeHTML` to inject the SVG string.

Here's the converted LitElement code:

```typescript
import { LitElement, html } from 'lit';
import { property } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { unsafeHTML } from 'lit/directives/unsafe-html.js';

// The SVG icon import remains the same
import svgIcon from '../../../icons/add-location.svg';

/**
 * WARNING: This is an autogenerated component.
 * Do not make any changes to this file or they will be overwritten on build.
 * The template for this file is located in the generate-icons.js util file.
 */

/** @internal **/
export class RuxIconAddLocation extends LitElement {
    // Defines the custom element tag name, equivalent to Stencil's `tag` in @Component
    static is = 'rux-icon-add-location';

    // To match Stencil's `shadow: false`, we override createRenderRoot
    // to render directly into the light DOM.
    // Generally, LitElement recommends using Shadow DOM for better encapsulation.
    protected createRenderRoot(): Element | ShadowRoot {
        return this;
    }

    /**
     * The size of the icon. Can be 'extra-small', 'small', 'normal', 'large', 'auto' or any custom value ('30px', '1rem', '3.321em')
     */
    @property({ type: String })
    size:
        | 'extra-small'
        | 'small'
        | 'normal'
        | 'large'
        | 'auto'
        | string = 'auto';

    get iconSize(): string {
        const sizes: { [key: string]: string } = {
            'extra-small': '1rem',
            small: '2rem',
            normal: '3rem',
            large: '4rem',
        };

        if (sizes[this.size]) {
            return sizes[this.size];
        } else {
            return this.size;
        }
    }

    // Helper getter to create the style object for styleMap
    private get _iconDivStyle() {
        return {
            height: this.iconSize,
            width: this.iconSize,
        };
    }

    render() {
        // Use styleMap for dynamic inline styles and unsafeHTML to render the SVG string
        return html`
            <div style=${styleMap(this._iconDivStyle)}>${unsafeHTML(svgIcon)}</div>
        `;
    }
}

// Don't forget to define your custom element so it can be used in the DOM.
// This is typically done once per application.
// You might want to guard this to prevent errors if imported multiple times.
if (!customElements.get(RuxIconAddLocation.is)) {
    customElements.define(RuxIconAddLocation.is, RuxIconAddLocation);
}
```