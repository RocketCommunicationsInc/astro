To convert your Stencil.js component to LitElement, we'll make the following changes:

1.  **Imports**: Replace Stencil-specific imports (`Component`, `Prop`, `h`) with Lit's core (`LitElement`, `html`, `css`) and decorators (`customElement`, `property`), as well as `unsafeHTML` for rendering the SVG string.
2.  **Class Decorator**: Replace `@Component` with `@customElement`.
3.  **Properties**: Replace `@Prop()` with `@property()`.
4.  **Styling**:
    *   Lit components use `static styles = css`` for encapsulated styles within the Shadow DOM. We'll add some sensible defaults for an icon component.
    *   Inline styles within `render()` are passed as an object to the `style` attribute.
5.  **Render Method**: Replace Stencil's JSX (`h` or `<element>`) with Lit's `html` tagged template literal. Use `unsafeHTML` to inject the SVG string safely.
6.  **Shadow DOM**: Stencil's `shadow: false` meant the component rendered to the light DOM. Lit components default to Shadow DOM, which is generally preferred for encapsulation. For an icon, Shadow DOM is usually perfectly acceptable and beneficial. I've opted for Lit's default Shadow DOM behavior. If you *must* render to the light DOM, you would need to add `protected createRenderRoot(): Element | ShadowRoot { return this; }` to your class, but this is often not necessary and can lead to styling conflicts.

Here's the converted LitElement component:

```typescript
import { LitElement, html, css } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { unsafeHTML } from 'lit/directives/unsafe-html.js'; // Needed for rendering raw SVG string

import svgIcon from '../../../icons/all-out.svg'; // Assumes your bundler is configured to import SVG files as strings

/**
 * WARNING: This is an autogenerated component.
 * Do not make any changes to this file or they will be overwritten on build.
 * The template for this file is located in the generate-icons.js util file.
 */

/** @internal **/
@customElement('rux-icon-all-out')
export class RuxIconAllOut extends LitElement {
    /**
     * The size of the icon. Can be 'extra-small', 'small', 'normal', 'large', 'auto' or any custom value ('30px', '1rem', '3.321em')
     */
    @property({ type: String })
    size:
        | 'extra-small'
        | 'small'
        | 'normal'
        | 'large'
        | 'auto'
        | string = 'auto';

    /**
     * Defines the component's encapsulated styles.
     * These styles apply only to this component and its shadow DOM.
     */
    static styles = css`
        :host {
            display: inline-block; /* Ensures the custom element behaves like an inline block */
            line-height: 1; /* Prevents extra space below the icon, common for icon fonts/SVGs */
        }
        div {
            display: flex; /* Centers the SVG if its intrinsic size is smaller than the div */
            align-items: center;
            justify-content: center;
            /* The actual height/width will be set by the inline style from render() */
        }
        svg {
            display: block; /* Ensures SVG fills its container without extra space */
            fill: currentcolor; /* Common practice: icon inherits text color from parent */
        }
    `;

    get iconSize(): string {
        const sizes: { [key: string]: string } = {
            'extra-small': '1rem',
            small: '2rem',
            normal: '3rem',
            large: '4rem',
        };

        if (sizes[this.size]) {
            return sizes[this.size];
        } else {
            return this.size;
        }
    }

    render() {
        // Lit can directly apply a style object to the style attribute
        const inlineStyle = {
            height: this.iconSize,
            width: this.iconSize,
        };

        // Use unsafeHTML to render the raw SVG string.
        // Be cautious with unsafeHTML; ensure the SVG source is trusted.
        return html`<div style=${inlineStyle}>${unsafeHTML(svgIcon)}</div>`;
    }
}
```