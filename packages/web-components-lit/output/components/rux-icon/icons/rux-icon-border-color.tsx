To convert the Stencil.js component to LitElement, we'll replace Stencil's decorators and rendering logic with Lit's equivalents.

Key changes:
1.  **Imports**: Replace Stencil's core imports with `LitElement`, `html` from `lit`, and `property` from `lit/decorators.js`.
2.  **Class Definition**: Extend `LitElement` instead of using the `@Component` decorator.
3.  **Tag Name**: The `tag` property from `@Component` is commonly set via a `static tagName` property in Lit (or `static is`, though `tagName` is more modern and directly matches the custom element name).
4.  **Shadow DOM**: The original Stencil component has `shadow: false`. In Lit, the default is to use a shadow DOM. To mimic `shadow: false`, we must override the `createRenderRoot()` method to return `this`. This means the component's rendered content will be placed directly into its light DOM.
5.  **Properties**: `@Prop()` becomes `@property()`.
6.  **Rendering**: Stencil's `h` function is replaced by Lit's `html` tagged template literal. Inline styles are applied directly within the template. `innerHTML` is bound using the `.propertyName` syntax.

Here's the converted LitElement component:

```typescript
import { LitElement, html } from 'lit';
import { property } from 'lit/decorators.js'; // For the @property decorator
import svgIcon from '../../../icons/border-color.svg'; // This import remains the same

/**
 * WARNING: This is an autogenerated component.
 * Do not make any changes to this file or they will be overwritten on build.
 * The template for this file is located in the generate-icons.js util file.
 */

/** @internal **/
export class RuxIconBorderColor extends LitElement {
    // Define the custom element tag name.
    // This replaces the `tag` property in Stencil's @Component decorator.
    static override tagName = 'rux-icon-border-color';

    // To replicate Stencil's `shadow: false`, override `createRenderRoot`.
    // This makes the component render its content directly into its light DOM.
    // Be aware that with this approach, `static get styles` (if you were to add them)
    // would apply globally and not be encapsulated. Inline styles work as usual.
    override createRenderRoot() {
        return this;
    }

    /**
     * The size of the icon. Can be 'extra-small', 'small', 'normal', 'large', 'auto' or any custom value ('30px', '1rem', '3.321em')
     */
    // The @Prop() decorator from Stencil is replaced by @property() from Lit.
    // Type definition and default value remain the same.
    @property({ type: String })
    size:
        | 'extra-small'
        | 'small'
        | 'normal'
        | 'large'
        | 'auto'
        | string = 'auto';

    get iconSize(): string {
        const sizes: { [key: string]: string } = {
            'extra-small': '1rem',
            small: '2rem',
            normal: '3rem',
            large: '4rem',
        };

        if (sizes[this.size]) {
            return sizes[this.size];
        } else {
            return this.size;
        }
    }

    // The render method uses Lit's `html` tagged template literal.
    // Dynamic styles are applied directly using template literals.
    // innerHTML binding uses the Lit-specific `.propertyName` syntax.
    override render() {
        return html`
            <div
                style="height: ${this.iconSize}; width: ${this.iconSize};"
                .innerHTML="${svgIcon}"
            ></div>
        `;
    }
}

// If your build process (e.g., Rollup, Webpack) doesn't automatically
// define custom elements based on file name or a specific pattern,
// you'll need to manually define the component:
// customElements.define(RuxIconBorderColor.tagName, RuxIconBorderColor);
```